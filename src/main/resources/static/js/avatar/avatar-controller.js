/**\n * Contrôleur principal de l'avatar 3D\n * Coordonne le rendu, les animations, la communication WebSocket et Ready Player Me\n */\n\nclass AvatarController {\n    constructor() {\n        this.config = null;\n        this.renderer = null;\n        this.websocket = null;\n        this.readyPlayerMe = null;\n        \n        this.isInitialized = false;\n        this.currentEmotion = 'neutral';\n        this.currentAvatarId = null;\n        \n        // Éléments DOM\n        this.container = null;\n        this.statusElement = null;\n        this.speechBubble = null;\n        this.controls = null;\n        \n        this.setupEventListeners();\n    }\n    \n    /**\n     * Initialise le contrôleur d'avatar\n     */\n    async initialize() {\n        try {\n            console.log('Initialisation du contrôleur d\\'avatar...');\n            \n            // Initialiser la configuration\n            this.config = new AvatarConfig();\n            await this.waitForConfigLoad();\n            \n            // Initialiser les éléments DOM\n            this.initializeDOM();\n            \n            // Initialiser les composants\n            this.initializeRenderer();\n            this.initializeWebSocket();\n            this.initializeReadyPlayerMe();\n            \n            // Charger l'avatar par défaut\n            await this.loadDefaultAvatar();\n            \n            // Initialiser les contrôles UI\n            this.initializeControls();\n            \n            this.isInitialized = true;\n            this.updateStatus('Avatar prêt !', false);\n            \n            console.log('Contrôleur d\\'avatar initialisé avec succès');\n            \n        } catch (error) {\n            console.error('Erreur lors de l\\'initialisation:', error);\n            this.updateStatus('Erreur lors de l\\'initialisation', false);\n        }\n    }\n    \n    /**\n     * Attend que la configuration soit chargée\n     */\n    waitForConfigLoad() {\n        return new Promise((resolve) => {\n            if (this.config.get('enabled') !== null) {\n                resolve();\n            } else {\n                this.config.addEventListener('configLoaded', () => resolve());\n            }\n        });\n    }\n    \n    /**\n     * Initialise les éléments DOM\n     */\n    initializeDOM() {\n        this.container = document.getElementById('avatar-viewport');\n        this.statusElement = document.getElementById('status-text');\n        this.speechBubble = document.getElementById('speech-bubble');\n        this.controls = document.getElementById('avatar-controls');\n        \n        if (!this.container) {\n            throw new Error('Container avatar-viewport non trouvé');\n        }\n    }\n    \n    /**\n     * Initialise le moteur de rendu 3D\n     */\n    initializeRenderer() {\n        this.renderer = new AvatarRenderer(this.container, this.config);\n        console.log('Moteur de rendu initialisé');\n    }\n    \n    /**\n     * Initialise la connexion WebSocket\n     */\n    initializeWebSocket() {\n        this.websocket = new AvatarWebSocket(this.config);\n        \n        // Gestionnaires d'événements WebSocket\n        this.websocket.addEventListener('connected', () => {\n            console.log('WebSocket connecté');\n        });\n        \n        this.websocket.addEventListener('avatar_speech', (data) => {\n            this.handleSpeechMessage(data);\n        });\n        \n        this.websocket.addEventListener('avatar_emotion', (data) => {\n            this.handleEmotionMessage(data);\n        });\n        \n        this.websocket.addEventListener('avatar_gesture', (data) => {\n            this.handleGestureMessage(data);\n        });\n        \n        this.websocket.addEventListener('avatar_visibility', (data) => {\n            this.handleVisibilityMessage(data);\n        });\n        \n        this.websocket.addEventListener('avatar_appearance', (data) => {\n            this.handleAppearanceMessage(data);\n        });\n        \n        this.websocket.connect();\n        this.websocket.startKeepAlive();\n    }\n    \n    /**\n     * Initialise l'intégration Ready Player Me\n     */\n    initializeReadyPlayerMe() {\n        this.readyPlayerMe = new ReadyPlayerMeIntegration(this.config);\n        console.log('Ready Player Me initialisé, disponible:', this.readyPlayerMe.isAvailable());\n    }\n    \n    /**\n     * Charge l'avatar par défaut\n     */\n    async loadDefaultAvatar() {\n        this.updateStatus('Chargement de l\\'avatar...', true);\n        \n        try {\n            const gender = this.config.get('appearance.gender', 'female');\n            const age = this.config.get('appearance.age', 30);\n            const style = this.config.get('appearance.style', 'casual');\n            \n            let modelUrl;\n            \n            if (this.readyPlayerMe.isAvailable()) {\n                // Utiliser Ready Player Me\n                const defaultAvatarId = this.config.get('readyPlayerMe.defaultAvatarId');\n                modelUrl = await this.readyPlayerMe.getAvatarModelUrl(defaultAvatarId);\n                this.currentAvatarId = defaultAvatarId;\n            } else {\n                // Utiliser le modèle de fallback\n                modelUrl = this.config.getAvatarModelPath(gender, age, style);\n            }\n            \n            await this.renderer.loadAvatar(modelUrl);\n            \n            this.updateStatus('Avatar chargé !', false);\n            \n        } catch (error) {\n            console.error('Erreur lors du chargement de l\\'avatar:', error);\n            this.updateStatus('Erreur de chargement', false);\n        }\n    }\n    \n    /**\n     * Initialise les contrôles UI\n     */\n    initializeControls() {\n        // Bouton de basculement des contrôles\n        const toggleButton = document.getElementById('toggle-controls');\n        if (toggleButton) {\n            toggleButton.addEventListener('click', () => {\n                this.toggleControls();\n            });\n        }\n        \n        // Contrôles d'apparence\n        this.setupAppearanceControls();\n        \n        // Contrôles d'émotion\n        this.setupEmotionControls();\n        \n        // Contrôles de gestes\n        this.setupGestureControls();\n        \n        // Contrôle de test vocal\n        this.setupSpeechControls();\n    }\n    \n    /**\n     * Configure les contrôles d'apparence\n     */\n    setupAppearanceControls() {\n        const genderSelect = document.getElementById('gender-select');\n        const ageSlider = document.getElementById('age-slider');\n        const ageDisplay = document.getElementById('age-display');\n        const styleSelect = document.getElementById('style-select');\n        \n        if (genderSelect) {\n            genderSelect.value = this.config.get('appearance.gender', 'female');\n            genderSelect.addEventListener('change', () => {\n                this.changeAppearance();\n            });\n        }\n        \n        if (ageSlider && ageDisplay) {\n            ageSlider.value = this.config.get('appearance.age', 30);\n            ageDisplay.textContent = `${ageSlider.value} ans`;\n            \n            ageSlider.addEventListener('input', () => {\n                ageDisplay.textContent = `${ageSlider.value} ans`;\n                this.updateSliderBackground(ageSlider);\n            });\n            \n            ageSlider.addEventListener('change', () => {\n                this.changeAppearance();\n            });\n            \n            this.updateSliderBackground(ageSlider);\n        }\n        \n        if (styleSelect) {\n            styleSelect.value = this.config.get('appearance.style', 'casual');\n            styleSelect.addEventListener('change', () => {\n                this.changeAppearance();\n            });\n        }\n    }\n    \n    /**\n     * Configure les contrôles d'émotion\n     */\n    setupEmotionControls() {\n        const emotionSelect = document.getElementById('emotion-select');\n        \n        if (emotionSelect) {\n            emotionSelect.value = this.currentEmotion;\n            emotionSelect.addEventListener('change', () => {\n                this.setEmotion(emotionSelect.value);\n            });\n        }\n    }\n    \n    /**\n     * Configure les contrôles de gestes\n     */\n    setupGestureControls() {\n        const gestureButtons = document.querySelectorAll('.gesture-btn');\n        \n        gestureButtons.forEach(button => {\n            button.addEventListener('click', () => {\n                const gesture = button.dataset.gesture;\n                this.playGesture(gesture);\n            });\n        });\n    }\n    \n    /**\n     * Configure les contrôles de test vocal\n     */\n    setupSpeechControls() {\n        const speechTextarea = document.getElementById('speech-text');\n        const speakButton = document.getElementById('speak-btn');\n        \n        if (speakButton && speechTextarea) {\n            speakButton.addEventListener('click', () => {\n                const text = speechTextarea.value.trim();\n                if (text) {\n                    this.speak(text, this.currentEmotion);\n                }\n            });\n        }\n    }\n    \n    /**\n     * Configure les événements globaux\n     */\n    setupEventListeners() {\n        // Gestion des raccourcis clavier\n        document.addEventListener('keydown', (event) => {\n            if (event.ctrlKey || event.metaKey) {\n                switch (event.key) {\n                    case 'h':\n                        event.preventDefault();\n                        this.toggleControls();\n                        break;\n                    case 's':\n                        event.preventDefault();\n                        this.showSpeechInput();\n                        break;\n                }\n            }\n        });\n    }\n    \n    /**\n     * Gère les messages de parole reçus du backend\n     */\n    handleSpeechMessage(data) {\n        const { text, emotion, duration } = data;\n        console.log('Message de parole reçu:', text);\n        \n        // Afficher la bulle de dialogue\n        this.showSpeechBubble(text);\n        \n        // Changer l'émotion si spécifiée\n        if (emotion && emotion !== this.currentEmotion) {\n            this.setEmotion(emotion);\n        }\n        \n        // Jouer l'animation de parole\n        this.renderer.playAnimation('speaking', { loop: true, fadeIn: 0.3 });\n        \n        // Masquer la bulle après la durée spécifiée\n        setTimeout(() => {\n            this.hideSpeechBubble();\n            this.renderer.stopAnimation('speaking', 0.3);\n            this.renderer.playAnimation('idle', { loop: true, fadeIn: 0.3 });\n        }, duration || 3000);\n    }\n    \n    /**\n     * Gère les messages d'émotion reçus du backend\n     */\n    handleEmotionMessage(data) {\n        const { emotion, intensity } = data;\n        console.log('Changement d\\'émotion reçu:', emotion, intensity);\n        \n        this.setEmotion(emotion, intensity);\n        \n        // Mettre à jour l'interface\n        const emotionSelect = document.getElementById('emotion-select');\n        if (emotionSelect) {\n            emotionSelect.value = emotion;\n        }\n    }\n    \n    /**\n     * Gère les messages de geste reçus du backend\n     */\n    handleGestureMessage(data) {\n        const { gestureType } = data;\n        console.log('Geste reçu:', gestureType);\n        \n        this.playGesture(gestureType);\n    }\n    \n    /**\n     * Gère les messages de visibilité reçus du backend\n     */\n    handleVisibilityMessage(data) {\n        const { visible } = data;\n        console.log('Changement de visibilité:', visible);\n        \n        if (visible) {\n            this.showAvatar();\n        } else {\n            this.hideAvatar();\n        }\n    }\n    \n    /**\n     * Gère les messages de changement d'apparence reçus du backend\n     */\n    async handleAppearanceMessage(data) {\n        const { modelUrl, gender, age, style } = data;\n        console.log('Changement d\\'apparence:', data);\n        \n        this.updateStatus('Chargement du nouvel avatar...', true);\n        \n        try {\n            await this.renderer.loadAvatar(modelUrl);\n            \n            // Mettre à jour les contrôles UI\n            const genderSelect = document.getElementById('gender-select');\n            const ageSlider = document.getElementById('age-slider');\n            const ageDisplay = document.getElementById('age-display');\n            const styleSelect = document.getElementById('style-select');\n            \n            if (genderSelect) genderSelect.value = gender;\n            if (ageSlider) {\n                ageSlider.value = age;\n                this.updateSliderBackground(ageSlider);\n            }\n            if (ageDisplay) ageDisplay.textContent = `${age} ans`;\n            if (styleSelect) styleSelect.value = style;\n            \n            this.updateStatus('Avatar mis à jour !', false);\n            \n        } catch (error) {\n            console.error('Erreur lors du changement d\\'apparence:', error);\n            this.updateStatus('Erreur de chargement', false);\n        }\n    }\n    \n    /**\n     * Change l'apparence de l'avatar\n     */\n    async changeAppearance() {\n        const genderSelect = document.getElementById('gender-select');\n        const ageSlider = document.getElementById('age-slider');\n        const styleSelect = document.getElementById('style-select');\n        \n        if (!genderSelect || !ageSlider || !styleSelect) return;\n        \n        const gender = genderSelect.value;\n        const age = parseInt(ageSlider.value);\n        const style = styleSelect.value;\n        \n        console.log('Changement d\\'apparence:', { gender, age, style });\n        \n        this.updateStatus('Création de l\\'avatar...', true);\n        \n        try {\n            let modelUrl;\n            \n            if (this.readyPlayerMe.isAvailable()) {\n                // Créer un nouvel avatar avec Ready Player Me\n                const result = await this.readyPlayerMe.createAvatar({\n                    gender, age, style\n                });\n                modelUrl = await this.readyPlayerMe.getAvatarModelUrl(result.id);\n                this.currentAvatarId = result.id;\n            } else {\n                // Utiliser le modèle de fallback\n                modelUrl = this.config.getAvatarModelPath(gender, age, style);\n            }\n            \n            await this.renderer.loadAvatar(modelUrl);\n            \n            // Notifier le backend du changement\n            if (this.websocket.isConnectedAndReady()) {\n                this.websocket.sendMessage('appearance_changed', {\n                    gender, age, style, modelUrl\n                });\n            }\n            \n            this.updateStatus('Avatar mis à jour !', false);\n            \n        } catch (error) {\n            console.error('Erreur lors du changement d\\'apparence:', error);\n            this.updateStatus('Erreur de création', false);\n        }\n    }\n    \n    /**\n     * Définit l'émotion de l'avatar\n     */\n    setEmotion(emotion, intensity = 0.7) {\n        if (!this.isInitialized) return;\n        \n        this.currentEmotion = emotion;\n        this.renderer.setEmotion(emotion, intensity);\n        \n        console.log(`Émotion changée: ${emotion}`);\n    }\n    \n    /**\n     * Fait jouer un geste à l'avatar\n     */\n    playGesture(gestureType) {\n        if (!this.isInitialized) return;\n        \n        this.renderer.playGesture(gestureType);\n        \n        console.log(`Geste joué: ${gestureType}`);\n    }\n    \n    /**\n     * Fait parler l'avatar\n     */\n    speak(text, emotion = null) {\n        if (!this.isInitialized) return;\n        \n        const finalEmotion = emotion || this.currentEmotion;\n        \n        // Envoyer au backend via WebSocket\n        if (this.websocket.isConnectedAndReady()) {\n            this.websocket.sendMessage('speak_request', {\n                text, emotion: finalEmotion\n            });\n        } else {\n            // Mode hors ligne - simulation locale\n            this.handleSpeechMessage({\n                text, emotion: finalEmotion, duration: text.length * 100\n            });\n        }\n    }\n    \n    /**\n     * Affiche la bulle de dialogue\n     */\n    showSpeechBubble(text) {\n        if (!this.speechBubble) return;\n        \n        const textDisplay = document.getElementById('speech-text-display');\n        if (textDisplay) {\n            textDisplay.textContent = text;\n        }\n        \n        this.speechBubble.classList.remove('hidden');\n    }\n    \n    /**\n     * Masque la bulle de dialogue\n     */\n    hideSpeechBubble() {\n        if (this.speechBubble) {\n            this.speechBubble.classList.add('hidden');\n        }\n    }\n    \n    /**\n     * Affiche l'avatar\n     */\n    showAvatar() {\n        if (this.container) {\n            this.container.style.opacity = '1';\n            this.container.style.pointerEvents = 'auto';\n        }\n    }\n    \n    /**\n     * Masque l'avatar\n     */\n    hideAvatar() {\n        if (this.container) {\n            this.container.style.opacity = '0.3';\n            this.container.style.pointerEvents = 'none';\n        }\n    }\n    \n    /**\n     * Bascule l'affichage des contrôles\n     */\n    toggleControls() {\n        if (this.controls) {\n            this.controls.classList.toggle('hidden');\n        }\n    }\n    \n    /**\n     * Ouvre l'interface de création d'avatar Ready Player Me\n     */\n    async openAvatarCreator() {\n        if (!this.readyPlayerMe.isAvailable()) {\n            alert('Ready Player Me n\\'est pas disponible');\n            return;\n        }\n        \n        try {\n            const result = await this.readyPlayerMe.openAvatarCreator();\n            console.log('Avatar créé:', result);\n            \n            // Charger le nouvel avatar\n            await this.renderer.loadAvatar(result.modelUrl);\n            this.currentAvatarId = result.avatarId;\n            \n            this.updateStatus('Nouvel avatar chargé !', false);\n            \n        } catch (error) {\n            console.error('Erreur lors de la création d\\'avatar:', error);\n        }\n    }\n    \n    /**\n     * Affiche l'input de test vocal\n     */\n    showSpeechInput() {\n        const speechTextarea = document.getElementById('speech-text');\n        if (speechTextarea) {\n            speechTextarea.focus();\n            \n            // Afficher les contrôles si cachés\n            if (this.controls && this.controls.classList.contains('hidden')) {\n                this.toggleControls();\n            }\n        }\n    }\n    \n    /**\n     * Met à jour l'arrière-plan du slider d'âge\n     */\n    updateSliderBackground(slider) {\n        const value = (slider.value - slider.min) / (slider.max - slider.min) * 100;\n        slider.style.background = `linear-gradient(to right, var(--primary-color) 0%, var(--primary-color) ${value}%, #ddd ${value}%, #ddd 100%)`;\n    }\n    \n    /**\n     * Met à jour le statut affiché\n     */\n    updateStatus(message, showSpinner = false) {\n        if (this.statusElement) {\n            this.statusElement.textContent = message;\n        }\n        \n        const spinner = document.getElementById('loading-spinner');\n        if (spinner) {\n            spinner.style.display = showSpinner ? 'block' : 'none';\n        }\n    }\n    \n    /**\n     * Nettoie les ressources\n     */\n    dispose() {\n        if (this.renderer) {\n            this.renderer.dispose();\n        }\n        \n        if (this.websocket) {\n            this.websocket.stopKeepAlive();\n            this.websocket.disconnect();\n        }\n        \n        if (this.readyPlayerMe) {\n            this.readyPlayerMe.clearCache();\n        }\n        \n        console.log('Contrôleur d\\'avatar nettoyé');\n    }\n    \n    /**\n     * Obtient les informations de debug\n     */\n    getDebugInfo() {\n        return {\n            initialized: this.isInitialized,\n            currentEmotion: this.currentEmotion,\n            currentAvatarId: this.currentAvatarId,\n            websocketConnected: this.websocket?.isConnectedAndReady(),\n            readyPlayerMeAvailable: this.readyPlayerMe?.isAvailable(),\n            renderer: this.renderer?.getDebugInfo()\n        };\n    }\n}\n\n// Export global\nwindow.AvatarController = AvatarController;"