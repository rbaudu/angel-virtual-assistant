/**
 * DIAGNOSTIC AVANC√â pour l'avatar - Fichier avatar-debug.js
 * √Ä ajouter dans src/main/resources/static/js/avatar-debug.js
 */

// Fonctions de diagnostic global
window.avatarDiagnostic = {
    
    /**
     * Test complet du syst√®me de rendu
     */
    fullDiagnostic() {
        console.log('üîç === DIAGNOSTIC COMPLET AVATAR ===');
        
        // 1. V√©rifier les d√©pendances
        this.checkDependencies();
        
        // 2. V√©rifier les √©l√©ments DOM
        this.checkDOM();
        
        // 3. V√©rifier l'instance Angel
        this.checkAngelApp();
        
        // 4. V√©rifier le renderer
        this.checkRenderer();
        
        // 5. V√©rifier la sc√®ne 3D
        this.checkScene();
        
        // 6. Test de rendu
        this.testRendering();
        
        console.log('üîç === FIN DIAGNOSTIC ===');
    },
    
    /**
     * V√©rifier les d√©pendances
     */
    checkDependencies() {
        console.log('üìö V√©rification des d√©pendances:');
        
        const deps = {
            'THREE': typeof THREE !== 'undefined',
            'THREE.WebGLRenderer': typeof THREE !== 'undefined' && !!THREE.WebGLRenderer,
            'THREE.Scene': typeof THREE !== 'undefined' && !!THREE.Scene,
            'THREE.PerspectiveCamera': typeof THREE !== 'undefined' && !!THREE.PerspectiveCamera,
            'THREE.GLTFLoader': typeof THREE !== 'undefined' && !!THREE.GLTFLoader,
            'AngelAvatarApp': typeof window.AngelAvatarApp !== 'undefined',
            'AvatarRenderer': typeof window.AvatarRenderer !== 'undefined'
        };
        
        for (const [name, available] of Object.entries(deps)) {
            console.log(`  ${available ? '‚úÖ' : '‚ùå'} ${name}`);
        }
        
        return Object.values(deps).every(d => d);
    },
    
    /**
     * V√©rifier les √©l√©ments DOM
     */
    checkDOM() {
        console.log('üèóÔ∏è V√©rification DOM:');
        
        const elements = [
            'avatar-container',
            'avatar-viewport', 
            'avatar-status',
            'message-bubble',
            'loading-spinner'
        ];
        
        elements.forEach(id => {
            const el = document.getElementById(id);
            const rect = el ? el.getBoundingClientRect() : null;
            
            console.log(`  ${el ? '‚úÖ' : '‚ùå'} #${id}`, rect ? {
                width: rect.width,
                height: rect.height,
                visible: rect.width > 0 && rect.height > 0
            } : 'Non trouv√©');
        });
    },
    
    /**
     * V√©rifier l'instance AngelApp
     */
    checkAngelApp() {
        console.log('üé≠ V√©rification AngelApp:');
        
        if (window.angelApp) {
            console.log('  ‚úÖ Instance trouv√©e');
            console.log('  üìä √âtat:', {
                isInitialized: window.angelApp.isInitialized,
                hasRenderer: !!window.angelApp.avatarRenderer,
                initAttempts: window.angelApp.initAttempts || 0
            });
        } else {
            console.log('  ‚ùå Aucune instance AngelApp');
        }
    },
    
    /**
     * V√©rifier le renderer
     */
    checkRenderer() {
        console.log('üñ•Ô∏è V√©rification Renderer:');
        
        const renderer = window.angelApp?.avatarRenderer;
        if (!renderer) {
            console.log('  ‚ùå Pas de renderer');
            return;
        }
        
        console.log('  ‚úÖ Renderer trouv√©');
        console.log('  üìä √âtat:', {
            hasScene: !!renderer.scene,
            hasCamera: !!renderer.camera,
            hasRenderer: !!renderer.renderer,
            isRendering: renderer.isRendering,
            containerHasCanvas: !!renderer.container?.querySelector('canvas')
        });
        
        if (renderer.renderer) {
            const size = new THREE.Vector2();
            renderer.renderer.getSize(size);
            console.log('  üìê Taille renderer:', size);
            console.log('  üé® Clear color:', renderer.renderer.getClearColor().getHex());
        }
    },
    
    /**
     * V√©rifier la sc√®ne 3D
     */
    checkScene() {
        console.log('üé¨ V√©rification Sc√®ne:');
        
        const renderer = window.angelApp?.avatarRenderer;
        if (!renderer?.scene) {
            console.log('  ‚ùå Pas de sc√®ne');
            return;
        }
        
        const scene = renderer.scene;
        console.log('  ‚úÖ Sc√®ne trouv√©e');
        console.log('  üë• Objets dans la sc√®ne:', scene.children.length);
        
        scene.children.forEach((child, index) => {
            console.log(`    ${index}: ${child.type} (${child.name || 'sans nom'})`);
            
            if (child.isMesh) {
                console.log(`      üîπ Mesh visible: ${child.visible}`);
                console.log(`      üîπ Position:`, child.position);
                console.log(`      üîπ Scale:`, child.scale);
            }
        });
        
        // V√©rifier avatar sp√©cifiquement
        if (renderer.avatarModel) {
            console.log('  üë§ Avatar trouv√©:');
            const box = new THREE.Box3().setFromObject(renderer.avatarModel);
            console.log('    üì¶ Bounding box:', box);
            console.log('    üëÅÔ∏è Visible:', renderer.avatarModel.visible);
            console.log('    üìç Position:', renderer.avatarModel.position);
        }
    },
    
    /**
     * Test de rendu avec objets simples
     */
    testRendering() {
        console.log('üß™ Test de rendu:');
        
        const renderer = window.angelApp?.avatarRenderer;
        if (!renderer) {
            console.log('  ‚ùå Impossible de tester sans renderer');
            return;
        }
        
        try {
            // Test 1: Ajouter un cube rouge simple
            console.log('  üé≤ Test cube rouge...');
            this.addTestCube(renderer);
            
            // Test 2: Forcer un rendu
            console.log('  üñºÔ∏è Force rendu...');
            if (renderer.renderer && renderer.scene && renderer.camera) {
                renderer.renderer.render(renderer.scene, renderer.camera);
                console.log('    ‚úÖ Rendu ex√©cut√©');
            }
            
            // Test 3: V√©rifier le canvas
            const canvas = renderer.container?.querySelector('canvas');
            if (canvas) {
                console.log('    üì± Canvas:', {
                    width: canvas.width,
                    height: canvas.height,
                    style: {
                        display: canvas.style.display,
                        visibility: canvas.style.visibility,
                        opacity: canvas.style.opacity
                    }
                });
            }
            
        } catch (error) {
            console.error('  ‚ùå Erreur test rendu:', error);
        }
    },
    
    /**
     * Ajouter un cube de test visible
     */
    addTestCube(renderer) {
        // Supprimer ancien cube
        const oldCube = renderer.scene.getObjectByName('diagnosticCube');
        if (oldCube) {
            renderer.scene.remove(oldCube);
        }
        
        // Cr√©er nouveau cube avec mat√©riau tr√®s visible
        const geometry = new THREE.BoxGeometry(2, 2, 2);
        const material = new THREE.MeshBasicMaterial({ 
            color: 0xff0000,
            wireframe: false
        });
        const cube = new THREE.Mesh(geometry, material);
        
        cube.position.set(0, 0, 0);
        cube.name = 'diagnosticCube';
        
        renderer.scene.add(cube);
        
        console.log('    ‚úÖ Cube de diagnostic ajout√©');
        
        // Animation pour le rendre visible
        let rotation = 0;
        const animate = () => {
            if (cube.parent) {
                rotation += 0.02;
                cube.rotation.x = rotation;
                cube.rotation.y = rotation;
                
                if (rotation < Math.PI * 4) { // 2 tours
                    requestAnimationFrame(animate);
                }
            }
        };
        animate();
    },
    
    /**
     * Forcer la r√©initialisation compl√®te
     */
    forceReset() {
        console.log('üîÑ R√âINITIALISATION FORC√âE...');
        
        // 1. Nettoyer l'instance actuelle
        if (window.angelApp) {
            if (typeof window.angelApp.dispose === 'function') {
                window.angelApp.dispose();
            }
            window.angelApp = null;
            window.angelAppInstance = null;
        }
        
        // 2. Nettoyer le container
        const container = document.getElementById('avatar-viewport');
        if (container) {
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
        }
        
        // 3. Recr√©er l'instance
        setTimeout(() => {
            try {
                console.log('üé≠ Recr√©ation AngelAvatarApp...');
                window.angelApp = new AngelAvatarApp();
                window.angelApp.init().catch(console.error);
            } catch (error) {
                console.error('‚ùå Erreur recr√©ation:', error);
            }
        }, 1000);
    },
    
    /**
     * Test minimaliste de Three.js
     */
    testThreeJS() {
        console.log('üß™ TEST MINIMALISTE THREE.JS...');
        
        try {
            const container = document.getElementById('avatar-viewport');
            if (!container) {
                console.error('‚ùå Container manquant');
                return;
            }
            
            // Nettoyer
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            
            // Cr√©er sc√®ne simple
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);
            
            const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 5;
            
            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // Cr√©er cube
            const geometry = new THREE.BoxGeometry();
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
            
            // Animer
            const animate = () => {
                requestAnimationFrame(animate);
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;
                renderer.render(scene, camera);
            };
            
            animate();
            
            console.log('‚úÖ Test Three.js: cube vert qui tourne cr√©√©');
            
        } catch (error) {
            console.error('‚ùå Erreur test Three.js:', error);
        }
    }
};

// Raccourcis pour la console
window.diag = () => window.avatarDiagnostic.fullDiagnostic();
window.reset = () => window.avatarDiagnostic.forceReset();
window.test3d = () => window.avatarDiagnostic.testThreeJS();

console.log('üîß Avatar Diagnostic charg√©');
console.log('üí° Commandes disponibles:');
console.log('  diag() - Diagnostic complet');
console.log('  reset() - R√©initialisation forc√©e');
console.log('  test3d() - Test Three.js basique');