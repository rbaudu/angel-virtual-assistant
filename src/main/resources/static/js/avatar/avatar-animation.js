/**\n * Gestionnaire d'animations avancées pour l'avatar 3D\n * Gère la synchronisation labiale, les expressions faciales et les animations corporelles\n */\n\nclass AvatarAnimationManager {\n    constructor(avatarModel, mixer) {\n        this.avatarModel = avatarModel;\n        this.mixer = mixer;\n        \n        // Animations et actions\n        this.animations = new Map();\n        this.activeActions = new Map();\n        this.morphTargets = new Map();\n        \n        // État des animations\n        this.currentBaseAnimation = null;\n        this.currentEmotion = 'neutral';\n        this.isBlinking = false;\n        this.isSpeaking = false;\n        \n        // Timers et intervalles\n        this.blinkInterval = null;\n        this.idleMovementInterval = null;\n        \n        // Configuration\n        this.config = {\n            blinking: {\n                enabled: true,\n                frequency: 3500, // ms\n                duration: 150,   // ms\n                randomness: 0.4\n            },\n            lipSync: {\n                enabled: true,\n                smoothing: 0.3,\n                anticipation: 50 // ms\n            },\n            idleMovement: {\n                enabled: true,\n                frequency: 8000, // ms\n                intensity: 0.2\n            }\n        };\n        \n        this.initialize();\n    }\n    \n    /**\n     * Initialise le gestionnaire d'animations\n     */\n    initialize() {\n        this.setupMorphTargets();\n        this.startBlinking();\n        this.startIdleMovements();\n        \n        console.log('Gestionnaire d\\'animations initialisé');\n    }\n    \n    /**\n     * Configure les morph targets pour les expressions faciales\n     */\n    setupMorphTargets() {\n        this.avatarModel.traverse((child) => {\n            if (child.isMesh && child.morphTargetInfluences) {\n                const morphTargetDict = child.morphTargetDictionary;\n                if (morphTargetDict) {\n                    // Mappage des visemes pour la synchronisation labiale\n                    const visemeMapping = {\n                        'A': ['viseme_AA', 'mouthOpen'],\n                        'B': ['viseme_PP', 'mouthClosed'],\n                        'C': ['viseme_CH', 'mouthNarrow'],\n                        'D': ['viseme_DD', 'mouthPress'],\n                        'E': ['viseme_E', 'mouthSmile'],\n                        'F': ['viseme_FF', 'mouthFrown'],\n                        'G': ['viseme_kk', 'mouthWide'],\n                        'H': ['viseme_I', 'mouthTight'],\n                        'X': ['viseme_sil', 'mouthRest']\n                    };\n                    \n                    // Mappage des émotions\n                    const emotionMapping = {\n                        'happy': ['browInnerUp', 'eyeSquintLeft', 'eyeSquintRight', 'mouthSmileLeft', 'mouthSmileRight'],\n                        'sad': ['browDownLeft', 'browDownRight', 'mouthFrownLeft', 'mouthFrownRight'],\n                        'surprised': ['browInnerUp', 'eyeWideLeft', 'eyeWideRight', 'mouthFunnel'],\n                        'angry': ['browDownLeft', 'browDownRight', 'eyeSquintLeft', 'eyeSquintRight'],\n                        'concerned': ['browInnerUp', 'mouthPress'],\n                        'thoughtful': ['browDownLeft', 'browDownRight', 'mouthPucker'],\n                        'neutral': []\n                    };\n                    \n                    // Stocker les indices des morph targets\n                    for (const [viseme, targets] of Object.entries(visemeMapping)) {\n                        for (const target of targets) {\n                            if (target in morphTargetDict) {\n                                if (!this.morphTargets.has('visemes')) {\n                                    this.morphTargets.set('visemes', new Map());\n                                }\n                                this.morphTargets.get('visemes').set(viseme, {\n                                    mesh: child,\n                                    index: morphTargetDict[target]\n                                });\n                            }\n                        }\n                    }\n                    \n                    for (const [emotion, targets] of Object.entries(emotionMapping)) {\n                        for (const target of targets) {\n                            if (target in morphTargetDict) {\n                                if (!this.morphTargets.has('emotions')) {\n                                    this.morphTargets.set('emotions', new Map());\n                                }\n                                if (!this.morphTargets.get('emotions').has(emotion)) {\n                                    this.morphTargets.get('emotions').set(emotion, []);\n                                }\n                                this.morphTargets.get('emotions').get(emotion).push({\n                                    mesh: child,\n                                    index: morphTargetDict[target]\n                                });\n                            }\n                        }\n                    }\n                    \n                    // Clignement des yeux\n                    const blinkTargets = ['eyeBlinkLeft', 'eyeBlinkRight'];\n                    for (const target of blinkTargets) {\n                        if (target in morphTargetDict) {\n                            if (!this.morphTargets.has('blink')) {\n                                this.morphTargets.set('blink', []);\n                            }\n                            this.morphTargets.get('blink').push({\n                                mesh: child,\n                                index: morphTargetDict[target]\n                            });\n                        }\n                    }\n                }\n            }\n        });\n        \n        console.log('Morph targets configurés:', Array.from(this.morphTargets.keys()));\n    }\n    \n    /**\n     * Joue une animation par son nom\n     */\n    playAnimation(name, options = {}) {\n        if (!this.animations.has(name)) {\n            console.warn(`Animation '${name}' non trouvée`);\n            return null;\n        }\n        \n        const clip = this.animations.get(name);\n        const action = this.mixer.clipAction(clip);\n        \n        // Configuration de l'action\n        action.reset();\n        action.setEffectiveTimeScale(options.speed || 1);\n        action.setEffectiveWeight(options.weight || 1);\n        \n        if (options.loop) {\n            action.setLoop(THREE.LoopRepeat);\n        } else {\n            action.setLoop(THREE.LoopOnce);\n            action.clampWhenFinished = true;\n        }\n        \n        // Transition\n        if (options.fadeIn) {\n            action.fadeIn(options.fadeIn);\n        } else {\n            action.play();\n        }\n        \n        // Stocker l'action active\n        this.activeActions.set(name, action);\n        \n        return action;\n    }\n    \n    /**\n     * Arrête une animation\n     */\n    stopAnimation(name, fadeOut = 0.5) {\n        if (this.activeActions.has(name)) {\n            const action = this.activeActions.get(name);\n            \n            if (fadeOut > 0) {\n                action.fadeOut(fadeOut);\n            } else {\n                action.stop();\n            }\n            \n            this.activeActions.delete(name);\n        }\n    }\n    \n    /**\n     * Change l'émotion de l'avatar\n     */\n    setEmotion(emotion, intensity = 0.7, duration = 0.8) {\n        if (emotion === this.currentEmotion) return;\n        \n        console.log(`Transition vers l'émotion: ${emotion}`);\n        \n        // Réinitialiser l'émotion précédente\n        this.resetEmotionMorphTargets();\n        \n        // Appliquer la nouvelle émotion\n        if (this.morphTargets.has('emotions') && this.morphTargets.get('emotions').has(emotion)) {\n            const targets = this.morphTargets.get('emotions').get(emotion);\n            \n            targets.forEach(target => {\n                this.animateMorphTarget(target.mesh, target.index, intensity, duration);\n            });\n        }\n        \n        this.currentEmotion = emotion;\n    }\n    \n    /**\n     * Synchronisation labiale avec un texte et des données de visemes\n     */\n    performLipSync(text, visemeData = null) {\n        if (!this.config.lipSync.enabled) return;\n        \n        console.log('Début de la synchronisation labiale:', text);\n        this.isSpeaking = true;\n        \n        if (visemeData && visemeData.length > 0) {\n            // Utiliser les données de visemes fournies\n            this.playVisemeSequence(visemeData);\n        } else {\n            // Générer une séquence de visemes basique\n            this.generateBasicLipSync(text);\n        }\n    }\n    \n    /**\n     * Joue une séquence de visemes\n     */\n    playVisemeSequence(visemeData) {\n        let timeOffset = 0;\n        \n        visemeData.forEach(viseme => {\n            setTimeout(() => {\n                this.setViseme(viseme.phoneme, viseme.intensity || 0.8);\n            }, timeOffset + viseme.time);\n            \n            timeOffset = viseme.time + viseme.duration;\n        });\n        \n        // Retour au repos après la séquence\n        setTimeout(() => {\n            this.setViseme('X', 0); // Position de repos\n            this.isSpeaking = false;\n        }, timeOffset + 200);\n    }\n    \n    /**\n     * Génère une synchronisation labiale basique\n     */\n    generateBasicLipSync(text) {\n        const phonemes = this.textToPhonemes(text);\n        const duration = text.length * 100; // Durée estimée\n        const phonemeDuration = duration / phonemes.length;\n        \n        phonemes.forEach((phoneme, index) => {\n            setTimeout(() => {\n                this.setViseme(phoneme, 0.7);\n            }, index * phonemeDuration);\n        });\n        \n        // Retour au repos\n        setTimeout(() => {\n            this.setViseme('X', 0);\n            this.isSpeaking = false;\n        }, duration);\n    }\n    \n    /**\n     * Convertit le texte en phonèmes basiques\n     */\n    textToPhonemes(text) {\n        // Mapping très simplifié français -> visemes\n        const phonemeMap = {\n            'a': 'A', 'à': 'A', 'â': 'A',\n            'e': 'E', 'é': 'E', 'è': 'E', 'ê': 'E',\n            'i': 'H', 'î': 'H',\n            'o': 'A', 'ô': 'A', 'ö': 'A',\n            'u': 'G', 'ù': 'G', 'û': 'G',\n            'b': 'B', 'p': 'B', 'm': 'B',\n            'f': 'F', 'v': 'F',\n            'l': 'D', 'n': 'D', 't': 'D',\n            'c': 'C', 'k': 'C', 'g': 'C',\n            'r': 'G', 'j': 'C',\n            ' ': 'X'\n        };\n        \n        return text.toLowerCase().split('').map(char => \n            phonemeMap[char] || 'X'\n        ).filter((phoneme, index, arr) => \n            phoneme !== arr[index - 1] // Éliminer les doublons consécutifs\n        );\n    }\n    \n    /**\n     * Définit un viseme spécifique\n     */\n    setViseme(viseme, intensity) {\n        // Réinitialiser tous les visemes\n        this.resetVisemeMorphTargets();\n        \n        // Appliquer le nouveau viseme\n        if (this.morphTargets.has('visemes') && this.morphTargets.get('visemes').has(viseme)) {\n            const target = this.morphTargets.get('visemes').get(viseme);\n            this.setMorphTarget(target.mesh, target.index, intensity);\n        }\n    }\n    \n    /**\n     * Démarre le système de clignement automatique\n     */\n    startBlinking() {\n        if (!this.config.blinking.enabled) return;\n        \n        const scheduleNextBlink = () => {\n            const baseInterval = this.config.blinking.frequency;\n            const randomness = this.config.blinking.randomness;\n            const nextBlink = baseInterval + (Math.random() - 0.5) * baseInterval * randomness;\n            \n            this.blinkInterval = setTimeout(() => {\n                this.performBlink();\n                scheduleNextBlink();\n            }, nextBlink);\n        };\n        \n        scheduleNextBlink();\n        console.log('Clignement automatique activé');\n    }\n    \n    /**\n     * Effectue un clignement\n     */\n    performBlink() {\n        if (this.isBlinking || this.isSpeaking) return;\n        \n        this.isBlinking = true;\n        const duration = this.config.blinking.duration;\n        \n        // Fermer les yeux\n        this.setBlinkTargets(1.0);\n        \n        // Rouvrir les yeux\n        setTimeout(() => {\n            this.setBlinkTargets(0.0);\n            this.isBlinking = false;\n        }, duration);\n    }\n    \n    /**\n     * Contrôle les morph targets de clignement\n     */\n    setBlinkTargets(value) {\n        if (this.morphTargets.has('blink')) {\n            this.morphTargets.get('blink').forEach(target => {\n                this.setMorphTarget(target.mesh, target.index, value);\n            });\n        }\n    }\n    \n    /**\n     * Démarre les mouvements d'attente\n     */\n    startIdleMovements() {\n        if (!this.config.idleMovement.enabled) return;\n        \n        this.idleMovementInterval = setInterval(() => {\n            this.performIdleMovement();\n        }, this.config.idleMovement.frequency);\n        \n        console.log('Mouvements d\\'attente activés');\n    }\n    \n    /**\n     * Effectue un petit mouvement d'attente\n     */\n    performIdleMovement() {\n        if (this.isSpeaking) return;\n        \n        const intensity = this.config.idleMovement.intensity;\n        const movements = [\n            { type: 'head', axis: 'y', amount: (Math.random() - 0.5) * intensity },\n            { type: 'head', axis: 'x', amount: (Math.random() - 0.5) * intensity * 0.5 },\n            { type: 'eye', direction: Math.random() > 0.5 ? 'left' : 'right' }\n        ];\n        \n        const movement = movements[Math.floor(Math.random() * movements.length)];\n        this.applyIdleMovement(movement);\n    }\n    \n    /**\n     * Applique un mouvement d'attente\n     */\n    applyIdleMovement(movement) {\n        // Implémentation des mouvements subtils\n        // (nécessiterait l'accès aux bones de l'avatar)\n        console.log('Mouvement d\\'attente:', movement);\n    }\n    \n    /**\n     * Anime un morph target vers une valeur cible\n     */\n    animateMorphTarget(mesh, index, targetValue, duration) {\n        const startValue = mesh.morphTargetInfluences[index] || 0;\n        const startTime = Date.now();\n        \n        const animate = () => {\n            const elapsed = Date.now() - startTime;\n            const progress = Math.min(elapsed / (duration * 1000), 1);\n            \n            // Interpolation smooth\n            const easeProgress = 0.5 * (1 - Math.cos(progress * Math.PI));\n            const currentValue = startValue + (targetValue - startValue) * easeProgress;\n            \n            mesh.morphTargetInfluences[index] = currentValue;\n            \n            if (progress < 1) {\n                requestAnimationFrame(animate);\n            }\n        };\n        \n        animate();\n    }\n    \n    /**\n     * Définit directement un morph target\n     */\n    setMorphTarget(mesh, index, value) {\n        if (mesh.morphTargetInfluences && index < mesh.morphTargetInfluences.length) {\n            mesh.morphTargetInfluences[index] = Math.max(0, Math.min(1, value));\n        }\n    }\n    \n    /**\n     * Réinitialise tous les morph targets d'émotion\n     */\n    resetEmotionMorphTargets() {\n        if (this.morphTargets.has('emotions')) {\n            this.morphTargets.get('emotions').forEach(targets => {\n                targets.forEach(target => {\n                    this.setMorphTarget(target.mesh, target.index, 0);\n                });\n            });\n        }\n    }\n    \n    /**\n     * Réinitialise tous les morph targets de visemes\n     */\n    resetVisemeMorphTargets() {\n        if (this.morphTargets.has('visemes')) {\n            this.morphTargets.get('visemes').forEach(target => {\n                this.setMorphTarget(target.mesh, target.index, 0);\n            });\n        }\n    }\n    \n    /**\n     * Arrête le clignement automatique\n     */\n    stopBlinking() {\n        if (this.blinkInterval) {\n            clearTimeout(this.blinkInterval);\n            this.blinkInterval = null;\n        }\n    }\n    \n    /**\n     * Arrête les mouvements d'attente\n     */\n    stopIdleMovements() {\n        if (this.idleMovementInterval) {\n            clearInterval(this.idleMovementInterval);\n            this.idleMovementInterval = null;\n        }\n    }\n    \n    /**\n     * Nettoie les ressources\n     */\n    dispose() {\n        this.stopBlinking();\n        this.stopIdleMovements();\n        \n        this.activeActions.forEach(action => action.stop());\n        this.activeActions.clear();\n        this.animations.clear();\n        this.morphTargets.clear();\n        \n        console.log('Gestionnaire d\\'animations nettoyé');\n    }\n}\n\n// Export global\nwindow.AvatarAnimationManager = AvatarAnimationManager;"